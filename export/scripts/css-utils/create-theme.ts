import { writeFileSync, readFileSync, existsSync } from 'node:fs'
import { dirname, join } from 'node:path'
import { fileURLToPath } from 'node:url'
import clampGenerator from './clamp-generator.ts'
import { TokenSchema } from './schema.ts'
import tokensToTailwind from './tokens-to-tailwind.ts'
import { type AllTokens, DEFAULT_ROOT_SIZE } from './types.ts'
import { getDefaultTokensDir, parseFile, type TokensDir } from './validation.ts'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

function loadAllTokens(tokensDir: TokensDir): AllTokens {
	const colors = parseFile(TokenSchema.Colors, tokensDir, 'colors.json')
	const fonts = parseFile(TokenSchema.Fonts, tokensDir, 'fonts.json')
	const spacing = parseFile(TokenSchema.Spacing, tokensDir, 'spacing.json')
	const leading = parseFile(TokenSchema.Leading, tokensDir, 'text-leading.json')
	const sizes = parseFile(TokenSchema.Sizes, tokensDir, 'text-sizes.json')
	const weights = parseFile(TokenSchema.Weights, tokensDir, 'text-weights.json')
	const viewports = parseFile(
		TokenSchema.Viewports,
		tokensDir,
		'viewports.json',
	)

	return { colors, fonts, spacing, leading, sizes, weights, viewports }
}

type CreateThemeOptions = {
	rootSize?: number
	tokensDir?: string
}

function createTheme(options: CreateThemeOptions = {}) {
	const rootSize = options.rootSize ?? DEFAULT_ROOT_SIZE
	const tokensDir = options.tokensDir ?? getDefaultTokensDir()
	const {
		colors: colorTokens,
		fonts: fontTokens,
		spacing: spacingTokens,
		leading: textLeadingTokens,
		sizes: textSizeTokens,
		weights: textWeightTokens,
		viewports: viewportTokens,
	} = loadAllTokens(tokensDir)

	const spacing = tokensToTailwind(
		clampGenerator(spacingTokens.items, viewportTokens, rootSize),
	)
	const colors = tokensToTailwind(colorTokens.items)
	const fontFamily = tokensToTailwind(fontTokens.items)
	const fontWeight = tokensToTailwind(
		textWeightTokens.items.map(({ name, value }) => ({
			name,
			value: String(value),
		})),
	)
	const fontSize = tokensToTailwind(
		clampGenerator(textSizeTokens.items, viewportTokens, rootSize),
	)
	const lineHeight = tokensToTailwind(
		textLeadingTokens.items.map(({ name, value }) => ({
			name,
			value: String(value),
		})),
	)

	const formatTokens = (tokens: Record<string, string>, prefix: string) => {
		return Object.entries(tokens)
			.map(([key, value]) => `\t--${prefix}-${key}: ${value};`)
			.join('\n')
	}

	const header = `/* AUTO-GENERATED by scripts/css-utils/create-theme.ts — Do NOT edit directly. */\n\n`

	// Derive breakpoints directly from viewports.json — keys become Tailwind prefixes
	const toRem = (px: number) => `${px / rootSize}rem`
	const breakpointLines = Object.entries(viewportTokens.breakpoints)
		.map(([name, px]) => `\t--breakpoint-${name}: ${toRem(px)};`)
		.join('\n')

	const body = `@theme {
${breakpointLines}
${formatTokens(spacing, 'spacing')}
\t--spacing-0: 0;
\t--spacing-auto: auto;
\t--spacing-full: 100%;
${formatTokens(colors, 'color')}
\t--color-black: #000;
\t--color-white: #fff;
\t--color-current: currentColor;
\t--color-transparent: transparent;
${formatTokens(fontFamily, 'font')}
${formatTokens(fontWeight, 'font-weight')}
${formatTokens(fontSize, 'text')}
${formatTokens(lineHeight, 'leading')}
}
`

	return header + body
}

type WriteThemeOptions = {
	outputPath?: string
	tokensDir?: string
	rootSize?: number
}

async function writeThemeToFile(
	options: WriteThemeOptions | string = 'theme.css',
): Promise<{ written: boolean; path: string }> {
	const outputPath =
		typeof options === 'string' ? options : (options.outputPath ?? 'theme.css')
	const themeContent = createTheme(
		typeof options === 'string'
			? {}
			: { tokensDir: options.tokensDir, rootSize: options.rootSize },
	)
	const fullPath =
		outputPath.startsWith('/') || outputPath.includes(':')
			? outputPath
			: join(__dirname, '..', '..', outputPath)

	try {
		if (existsSync(fullPath)) {
			try {
				const current = readFileSync(fullPath, 'utf8')
				const stripHeader = (content: string) =>
					content.replace(
						/\/\* AUTO-GENERATED .* — Do NOT edit directly\. \*\//,
						'',
					)
				if (stripHeader(current) === stripHeader(themeContent)) {
					return { written: false, path: fullPath }
				}
			} catch {}
		}
		writeFileSync(fullPath, themeContent, 'utf8')
		return { written: true, path: fullPath }
	} catch (error) {
		throw new Error(
			`Failed to write theme file: ${error instanceof Error ? error.message : String(error)}`,
		)
	}
}

async function handleCLI() {
	const args = process.argv.slice(2)
	let outputPath = 'theme.css'
	let tokensDir = ''
	let rootSize: number | undefined

	for (let i = 0; i < args.length; i++) {
		if (args[i] === '--output' || args[i] === '-o') {
			if (i + 1 < args.length) {
				outputPath = args[i + 1]!
				i++
			}
		} else if (args[i] === '--tokens' || args[i] === '-t') {
			if (i + 1 < args.length) {
				tokensDir = args[i + 1]!
				i++
			}
		} else if (args[i] === '--root-size') {
			if (i + 1 < args.length) {
				rootSize = Number(args[i + 1])
				i++
			}
		}
	}

	try {
		const result = await writeThemeToFile({
			outputPath,
			tokensDir: tokensDir || undefined,
			rootSize,
		})
		if (result.written) {
			console.log(`Theme file created at: ${result.path}`)
		} else {
			console.log(`Theme unchanged (no changes detected) at: ${result.path}`)
		}
	} catch (error) {
		console.error(
			`Failed to create theme file: ${error instanceof Error ? error.message : String(error)}`,
		)
		process.exit(1)
	}
}

if (import.meta.url === `file://${process.argv[1]}`) {
	await handleCLI()
}

export { writeThemeToFile, createTheme }
